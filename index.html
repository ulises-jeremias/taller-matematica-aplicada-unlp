<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Taller de Matemática Aplicada</title>
    <link rel="stylesheet" href="./css/reveal.css" />
    <link rel="stylesheet" href="./css/theme/solarized.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/atom-one-dark.css" />
    <link rel="stylesheet" href="./css/print/paper.css" type="text/css" media="print" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section ><section data-markdown><script type="text/template">

## Taller de
# Matemática Aplicada
</script></section><section data-markdown><script type="text/template">
## Docentes

-   Ulises Jeremias Cornejo Fandos
    _ucornejofandos@lifia.info.unlp.edu.ar_

-   Iván Mindlin
    <br />
    _mindlinster@gmail.com_
</script></section><section data-markdown><script type="text/template">
## Motivación
</script></section><section data-markdown><script type="text/template">
## Sobre el taller

- Taller de Matemática Aplicada
- Aplicamos conceptos vistos en la materia utilizando lenguajes de programación <!-- .element: class="fragment" -->
  - Haskell <!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
### Haskell

- Permite visualizar en forma más sencilla la solución a un determinado problema dada su similitud con el lenguaje matemático.
- Nos permite concentrarnos específicamente en el problema y su solución.
- A lo largo del taller conoceremos más sobre este lenguaje.
</script></section><section data-markdown><script type="text/template">
## Convenciones
</script></section><section data-markdown><script type="text/template">
### Equivalencia

Llamamos **Equivalencia** a como definimos en haskell las cosas que ya conocemos en Matemática.
</script></section><section data-markdown><script type="text/template">
## Plataforma de desarrollo

Para programar en este curso recomendamos las siguientes opciones:

- [Online Haskell Compiler](https://repl.it/languages/haskell)
- [Haskell Platform](https://www.haskell.org/platform)

</script></section></section><section ><section data-markdown><script type="text/template">
# Lógica
</script></section><section data-markdown><script type="text/template">
## Fundamento básicos
### Repaso
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

### Proposición

Oración declarativa a la cual se le puede asignar un valor verdad: _**verdadera (V)**_ o _**falsa (F)**_. 

Las proposiciones serán simbolizadas mediantes letras minúsculas: $p$, $q$, $r$, ...
</script></section><section data-markdown><script type="text/template">
### Ejercicios de repaso
</script></section><section data-markdown><script type="text/template">
_Determinar si los siguientes enunciados son proposiciones._

  - Siete es mayor que doce.
  - Si 6 > 4 entonces 6 > 2. <!-- .element: class="fragment" -->
  - Ella es inteligente. <!-- .element: class="fragment" -->
  - Quı́en es? <!-- .element: class="fragment" -->
  - En otros planetas del sistema solar hay diversos tipos de seres vivos. <!-- .element: class="fragment" -->
  - De 2 + 3 ≥ 5 + 4 se deduce 3 > 4. <!-- .element: class="fragment" -->
  - Estudiaré música o canto. <!-- .element: class="fragment" -->
  - Cualquier rectángulo tiene cuatro lados. <!-- .element: class="fragment" -->
  - x > 2. <!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

### Función proposicional

Dada una variable $x$ perteneciente al conjunto universal, se define una **función proposicional**, $p$, en la variable $x$, como un proceso que recibe $x$ y _**devuelve una proposión**_.

Una _proposición_ es una oración declarativa, _ó afirmación_, con un valor de verdad asociado.
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

En los lenguajes de programación no trabajamos con _"oraciones"_ como tal, sino que utilizamos directamente sus valores de verdad, es decir, Verdadero o Falso, _True_ o _False_, un **booleano** (Bool).
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

### Veamos unos ejemplos

-  2 es par
   **Verdadero** <!-- .element: class="fragment" -->
-  5 es par <!-- .element: class="fragment" -->
   **Falso** <!-- .element: class="fragment" -->
-  1 es par <!-- .element: class="fragment" -->
   **Falso** <!-- .element: class="fragment" -->


<div data-markdown>
    <br />

    <!-- .element: class="fragment" -->
    $p(x) = x$ es par, es una **función proposicional**. Por qué?
    
    <br />
    <br />

    El objetivo del taller es poder llevar los temas de la materia al ámbito de la computación. Para eso vamos a usar un lenguaje en particular, llamado **Haskell**.

    <br />
    <br />
</div>
</script></section><section data-markdown><script type="text/template">
## Introducción a Haskell
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

### Haskell

- Es un **lenguaje de programación funcional puro**.
- Lo utilizamos en el taller dado que presenta mayor relación con la matemática.
  - A diferencia de lenguajes imperativos como R-Info o Pascal.
- Esto permite escribir las ideas expresadas matemática, ó naturalmente, _directamente_ en el lenguaje de programación.
</script></section><section data-markdown><script type="text/template">
### ¿Cómo se expresan estas ideas?

Definiendo funciones.
</script></section><section data-markdown><script type="text/template">
Aunque después vamos a ver el concepto de función más formalmente en la materia, podemos dar una definición más natural:

<small class="fragment">
  Una _**función**_ es una caja que recibe uno, o más, elementos de un cierto _tipo_ y devuelve una sóla cosa de algún otro _tipo_. Es importante el concepto de que sólo se devuelve un elemento.
</small>
</script></section><section data-markdown><script type="text/template">
En Haskell es muy útil e importante declarar las funciones, así como en R-Info se definían variables. Veamos como se declaran y definen paso a paso.

<aside class="notes"><p>Mostrar en el pizarron paso a paso como declarar y definir una función.</p>
</aside></script></section><section data-markdown><script type="text/template">
<small>
  Esta función recibe un número entero (Int) y retorna el doble de ese número (Int).
</small>

```haskell
-- | double 2 = 4
-- | double 3 = 6
-- | double 4 = 8
-- | double (double 2) = ?
double :: Int -> Int
```
</script></section><section data-markdown><script type="text/template">Luego de declarar una función la definimos. Para esto podríamos decir cuánto vale la función para cada posible valor. Es importante que sólo podemos tener un resultado para un valor dado. Por ejemplo:
</script></section><section data-markdown><script type="text/template">

Algo que estaría **mal** es lo siguiente:

```haskell
double 2 = 4
double 2 = 3
```
</script></section><section data-markdown><script type="text/template">
No sólo porque no tiene ningún sentido si no que, por lo que mencionamos antes, **Una función NO puede tener dos resultados distintos para el mismo valor de entrada**.
</script></section><section data-markdown><script type="text/template">
### Definimos double

<small>
  Claramente, este trabajo de dar el valor para cada posible entrada es tedioso, así que la definimos como se puede ver a continuación:
</small>

```haskell
double :: Int -> Int
double x = 2 * x
```
<!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
### Problema

Una _función proposicional_, **¿qué tipo devuelve?** **¿qué recibe?**
</script></section><section data-markdown><script type="text/template">
### Función proposicional

Una funcion, en este caso proposicional, en Haskell debe declararse,

```haskell
p :: u -> Bool -- u es conjunto universal
```

- **u** representa al conjunto universal
- **-> Bool** quiere decir que devolveremos un valor de verdad, un _booleano_, es decir que los posibles resultados de la función son _True_ o _False_. _(En R-Info lo llamamos V y F)_
</script></section><section data-markdown><script type="text/template">
Para definir, e.g., la funcion proposional

_$r$($x$): $x$ es mayor que $0$_

lo hacemos de la siguiente forma:

```haskell
r :: Int -> Bool
r x = x > 0

-- donde x es cualquier valor perteneciente
-- a los Enteros, (Z), (Int).
```

<small>
  En las definicion anterior se pueden observar aspectos de haskell que iremos profundizando a medida que transcurre el taller.
</small>
</script></section><section data-markdown><script type="text/template">
### Equivalencias
## Operadores en Haskell
</script></section><section data-markdown><script type="text/template">
### Operadores Booleanos

```haskell
True && False   -- | AND lógico
True || False   -- | OR lógico
not True        -- | negación lógica
```
</script></section><section data-markdown><script type="text/template">
### Operadores Aritméticos

```haskell
2 + 3   -- | suma
3 - 2   -- | resta
4 * 2   -- | producto
1 / 2   -- | division
  .
  .
  .
```
</script></section><section data-markdown><script type="text/template">
## Operadores relacionales

```haskell
4 < 6    -- | menos que
3 <= 9   -- | menor o igual que
8 == 7   -- | igualdad
0 /= 1   -- | desigualdad
3 >= 2   -- | mayor o igual que
2 > 3    -- | mas que
```
</script></section><section data-markdown><script type="text/template">
## Problemas

Dadas las siguientes funciones proposicionales,

```haskell
-- Evalúa si un número divide a otro
-- divide (2, 4) = True
-- divide (3, 4) = False
divide :: (Int, Int) -> Bool

-- Evalúa si un número es par
-- esPar 2 = True
-- esPar 3 = False
esPar :: Int -> Bool
```
</script></section><section data-markdown><script type="text/template">
```haskell
divide :: (Int, Int) -> Bool
divide (d, x) = mod x d == 0

esPar :: Int -> Bool
esPar x = divide (2, x)
```
</script></section><section data-markdown><script type="text/template">
### Repasamos cosas de Haskell

```haskell
'c'   :: Char  -- caracter 'c' es de tipo Char
2     :: Int   -- 2 es de tipo Int, es decir, 2 pertenece a Z
True  :: Bool  -- True es de tipo Bool
False :: Bool  -- False es de tipo Bool
```
</script></section><section data-markdown><script type="text/template">
Definir las siguientes funciones

- $p$($n$): $n$ es par
- $q$($x$): $x$ es divisible por $2$
- $r$($x$): $x$ es igual $0$
- $c$($x$): $x$ es la letra 'c'
- $d$($y$): $y$ no es la letra 'c'
- $t$($x$, $y$): la suma entre $x$ e $y$ es igual a cero
- $w$($a$, $b$): $a$ es el opuesto de $b$
- $h$($n$, $m$): $n$ es igual a $0$ y $m$ no es la letra 'c'
- $a$($x$): 'x' es igual a 'x'
</script></section><section data-markdown><script type="text/template">
**SOLUCIONES**

```haskell
p :: Int -> Bool
p n = esPar n

q :: Int -> Bool
q x = divide (2, x)

r :: Int -> Bool
r x = x == 0

c :: Char -> Bool
c x = x == 'c'

d :: Char -> Bool
d x = not (c x)

t :: (Int, Int) -> Bool
t (x, y) = x + y == 0

w :: (Int, Int) -> Bool
w (a, b) = a == -b

h :: (Int, Char) -> Bool
h (n, m) = n == 0 && not (c m)

a :: u -> Bool
a x = True
```
</script></section></section><section ><section data-markdown><script type="text/template">
# Geometría
</script></section><section data-markdown><script type="text/template">
## Repaso
### Introducción a Haskell

<!-- .slide: style="text-align: left" -->

Esta sección del taller corresponde a la parte de Geometría de la materia. Sin embargo, por el momento vamos a seguir explorando Haskell así podemos utilizarlo para resolver problemas.
</script></section><section data-markdown><script type="text/template">
Para ello vamos a reforzar la idea de **Función** en _Haskell_.
</script></section><section data-markdown><script type="text/template">
Todas las funciones necesitan declararse. 

```haskell
-- Fahrenheit to Celsius
ftc :: Float -> Float
```

Primero aclaramos qué función vamos a declarar y luego indicamos qué cosas recibe, y qué cosas devuelve.
</script></section><section data-markdown><script type="text/template">
En este caso recibe algo de Tipo _**Int**_ y devuelve algo de Tipo _**Float**_. Pero...
</script></section><section data-markdown><script type="text/template">
### ¿Qué es un Tipo?

Cuando decimos que **algo es de un cierto tipo**, nos referimos a que ese _"algo"_ es un **valor qué pertenece a un determinado conjunto**. 

<small>
    Por ejemplo, cuando decimos que $x$ es de tipo Entero (_Int_ de Haskell), nos referimos a que los valores que puede tomar $x$ son valores enteros, es decir, $x$ pertenece al conjunto de los Enteros ($\mathcal{Z}$ matemático).
</small>

<aside class="notes"><p>Anticipar idea de expresión indicando lo importante que es cómo <em>denotar</em> un valor.</p>
</aside></script></section><section data-markdown><script type="text/template">
Las **expresiones** son formas de denotar un valor. Es decir el valor es una idea de lo que queremos representar, mientras que una expresión es la manera en la que _hablamos_ de ese valor. 

<aside class="notes"><p>Anotar en el pizarrón a las expresiones apuntando a los valores que pertenecen a un cierto tipo</p>
</aside></script></section><section data-markdown><script type="text/template">
Luego, se define la función $ftc$ como sigue:

```haskell
ftc :: Float -> Float
ftc x = (x - 32) * 5 / 9
```

<small>
    En este caso estamos diciendo que $ftc$ es una función que dado un $x$ flotante devuelve un flotante, que es la temperatura en celsius para la entrada x en fahrenheit.
</small>
</script></section><section data-markdown><script type="text/template">
### ¿Cómo usamos esta función?

La aplicamos.
</script></section><section data-markdown><script type="text/template">
La aplicación es una de las operaciones que podemos realizar con una función. En haskell lo expresamos con un espacio `" "`.
</script></section><section data-markdown><script type="text/template">
Por ejemplo, lo que en matemática haríamos de esta forma, $ftc(82)$, en haskell es como sigue:

```haskell
r 82.0
-- 27.77777777777778
```

<small>
    aplicamos la función $ftc$ a un valor entero, $82$, obteniendo un valor de salida flotante, _27.77777777777778_.
</small>
</script></section><section data-markdown><script type="text/template">
En terminos generales, podemos aplicar una función cualquiera a un valor cuyo **Tipo** sea el mismo que el **tipo de entrada** de la función. Y el resultado de la aplicación tendrá el tipo de salida de la misma.
</script></section><section data-markdown><script type="text/template">
En el ejemplo anterior

```haskell
ftc 82.0 :: Float
```
</script></section><section data-markdown><script type="text/template">
Como se habrán dado cuenta, el símbolo :: lo hemos utilizado para declarar una función, pero también para decir el tipo de _2.0_ , 'C', o incluso _ftc 2.0_ ¿Qué nos sugiere esto?
</script></section><section data-markdown><script type="text/template">
En haskell, al igual que en matemática, no diferenciamos lo que son funciones de los que son los valores. Es decir, una **función es un valor** que, al igual que el resto de los valores, tiene un **tipo**.
</script></section><section data-markdown><script type="text/template">
En este caso, cuando indicamos 

```haskell
ftc :: Float -> Float
```

estamos diciendo que el **tipo** de $ftc$ es _Float -> Float_ ¿Y esto qué implica? Si las funciones son "procesos" que reciben algo de un cierto tipo y devuelven otra cosa de un cierto tipo, y las funciones tienen un tipo, tiene sentido que una función pueda **recibir una función como parámetro de entrada**. Veamos cómo nos ayuda esto en la siguiente sección.

</script></section><section data-markdown><script type="text/template"><!-- .slide: style="text-align: left" -->

### Repaso
## Problemas

Escribir expresiones que tengan los siguientes tipos

-  (Int, Int)
-  Float
-  Char
-  Int -> Int
-  Bool -> (Bool, Bool)
</script></section><section data-markdown><script type="text/template">
## Geometría

<small>
    Existen situaciones en las cuales es conveniente expresar un problema a traves de un plano coordenado. Este se compone de dos ejes que representan dos variables. Por ejemplo el crecimiento de una población en función del tiempo.
</small>

<img src="../static/worldGrowth.png" alt="Imagen poblacion" width="250" height="250">

Caso de estudio: _Tenemos una variable, cuyo valor depende de otra variable_.
</script></section><section data-markdown><script type="text/template">
Expresemos, por ejemplo, la superficie de un terreno en función de uno de sus lados.

<aside class="notes"><p>Escribir el problema matemáticamente, y después en Haskell</p>
</aside></script></section><section data-markdown><script type="text/template">
Sabemos que un punto es un dato en el plano al cual le podemos atribuir un valor, por lo tanto, podemos definir funciones como las siguientes:

```haskell
abscisa :: (Float, Float) -> Float
```

```haskell
abscisa (x, y) = x
```
<!-- .element: class="fragment" -->

```haskell
ordenada :: (Float, Float) -> Float
```

```haskell
ordenada (x, y) = y
```
<!-- .element: class="fragment" -->

<aside class="notes"><p>preguntar cómo es</p>
</aside></script></section><section data-markdown><script type="text/template">
Supongamos que queremos sumar dos puntos. La suma entre dos puntos la definiremos de la siguiente forma:

```
Sean P = (a, b), Q = (c, d),

P + Q = (a + c, b + d)
```

<aside class="notes"><p>Hablar sobre recibir varios parámetros en una función</p>
</aside></script></section><section data-markdown><script type="text/template">
Cuando querramos recibir varios parámetros declararemos la función de la siguiente manera: 

*a0 -> a1 -> a2*

Donde *a0* y *a1* son los tipos de entrada, y *a2* es el tipo de salida. _En general_, siempre el último tipo indicado es el tipo de salida. Pero ¿No era que las funciones recibían una cosa y devolvían otra? ¿Una función puede recibir más de una cosa? *Ya veremos...*
</script></section><section data-markdown><script type="text/template">
### Regiones en el plano

Hagamos una función que nos diga si un punta dado *p* pertenece a una cierta región *r*.
</script></section><section data-markdown><script type="text/template">
### Rectas

Una recta es una relación entre dos valores, uno del eje X y otro del eje Y. Entonces es una función y por lo tanto podemos aplicar todas las propiedades que venimos trabajando hasta ahora. 

<aside class="notes"><p>Hacer que definan una función que me diga si un punta dado está en la recta</p>
</aside></script></section><section data-markdown><script type="text/template">
A veces nos da mayor legibilidad guardar ciertas ideas en variables. 

**Equivalencia**: Así como en matémica decimos "Sea x una variable real" o "Donde f es una función" en haskell tenemos las cláusulas _**let in**_ y _**where**_

<aside class="notes"><p>Habría que explicar el <em>let in</em>, y el <em>where</em></p>
</aside></script></section><section data-markdown><script type="text/template">
**let in**

Cláusula con la forma general:

```haskell
let x1 = e1
    x2 = e2
--  ...
--  xn = en
in expresionQueUsaLasVariables
```
</script></section><section data-markdown><script type="text/template">
**where**

Cláusula con la forma general:

```haskell
expresionQueUsa x1 x2 ... xn
	where x1 = e1
	      x2 = e2
	      ...
	      xn = en
```
</script></section><section data-markdown><script type="text/template">
</script></section></section><section ><section data-markdown><script type="text/template">
# HASKELL
</script></section><section data-markdown><script type="text/template">
## Repaso
# Rápido <!-- .element: class="fragment"-->
</script></section><section data-markdown><script type="text/template">
### Operadores Aritméticos

```haskell
ghci> 2 + 15  
17  
ghci> 49 * 100  
4900  
ghci> 1892 - 1472  
420  
ghci> 5 / 2  
2.5  
ghci>
```
</script></section><section data-markdown><script type="text/template">
#### Operadores Aritméticos combinados

```haskell
ghci> (50 * 100) - 4999  
1  
ghci> 50 * 100 - 4999  
1  
ghci> 50 * (100 - 4999)  
-244950
ghci>
```
</script></section><section data-markdown><script type="text/template">
### Operadores Booleanos

```haskell
ghci> True && False  
False  
ghci> True && True  
True  
ghci> False || True  
True   
ghci> not False  
True  
ghci> not (True && True)  
False
ghci>
```
</script></section><section data-markdown><script type="text/template">
### Igualdad

```haskell
ghci> 5 == 5  
True  
ghci> 1 == 0  
False  
ghci> 5 /= 5  
False  
ghci> 5 /= 4  
True  
ghci> "hello" == "hello"  
True
ghci>
```
</script></section><section data-markdown><script type="text/template">
## Definimos Funciones

```haskell
doubleMe x = x + x 
```
</script></section><section data-markdown><script type="text/template">
## Aplicamos Funciones

```haskell
ghci> doubleMe 9  
18  
ghci> doubleMe 8.3  
16.6
ghci>
```
</script></section><section data-markdown><script type="text/template">
## Funciones con más de un parámetro

```haskell
doubleUs x y = x*2 + y*2 
```
</script></section><section data-markdown><script type="text/template">
## Aplicamos

```haskell
ghci> doubleUs 4 9  
26  
ghci> doubleUs 2.3 34.2  
73.0  
ghci> doubleUs 28 88 + doubleMe 123  
478
ghci
```
</script></section><section data-markdown><script type="text/template">
## Reutilizamos definiciones

```haskell
-- doubleMe x = x + x
-- doubleUs x y = x*2 + y*2
doubleUs x y = doubleMe x + doubleMe y 
```
</script></section><section data-markdown><script type="text/template">
## Funciones partidas. Cómo?
</script></section><section data-markdown><script type="text/template">
```haskell
doubleSmallNumber x = if x > 100  
                        then x
                        else x * 2  
```
</script></section><section data-markdown><script type="text/template">
```haskell
-- doubleSmallNumber' x = (doubleSmallNumber x) + 1
doubleSmallNumber' x = (if x > 100 then x else x * 2) + 1
```
</script></section><section data-markdown><script type="text/template">
## Sintaxis en Funciones
</script></section><section data-markdown><script type="text/template">
### Pattern Matching

Consiste en una especificación de pautas que deben ser seguidas por los datos, los cuales pueden ser deconstruidos permitiéndonos acceder a sus componentes.

<img src="../static/meme_negro_confundido.jpg" class="fragment" alt="Imagen poblacion">
</script></section><section data-markdown><script type="text/template">
Llevandolo a lo que conocemos hasta ahora... Cuando nosotros definiamos una función planteabamos casos de ejemplo para guiarnos al buscar un término general.

```haskell
-- doubleMe 2 = 4
-- doubleMe 3 = 6
-- doubleMe 4 = 8
doubleMe x = x + x
```
</script></section><section data-markdown><script type="text/template">
Pero, **¿Qué pasa si uno de los casos no puede obtenerse con el caso general?**
</script></section><section data-markdown><script type="text/template">
Para eso nos sirve el **Pattern Matching**, para definir casos en base al parámetro de entrada!!
</script></section><section data-markdown><script type="text/template">
```haskell
lucky :: Int -> String
lucky 7 = "Uyy, un sieteeee ¡Genial!"
lucky x = "Meh, no me interesa"
```
</script></section><section data-markdown><script type="text/template">
Cuando llamamos a **lucky**, los patrones son verificados de arriba a abajo y cuando un patrón concuerda con el valor asociado, se utiliza el cuerpo de la función asociado. 

En este caso, la única forma de que un número concuerde con el primer patrón es que dicho número sea 7. Si no lo es,se evaluara el siguiente patrón, el cual coincide con cualquier valor y lo liga a x.
</script></section><section data-markdown><script type="text/template">
También se podría haber implementado utilizando una sentencia **if**. Pero, ¿qué pasaría si quisiéramos una función que nombrara los número del 1 al 5, o "No entre uno 1 y 5" para cualquier otro número?

Si no tuviéramos el ajuste de patrones deberíamos escribir una gran cantidad de **if then else**. Sin embargo con él:
</script></section><section data-markdown><script type="text/template">
```haskell
sayMe :: Int -> String
sayMe 1 = "Uno"
sayMe 2 = "Dos"
sayMe 3 = "Tres"
sayMe 4 = "Cuatro"
sayMe 5 = "Cinco"
sayMe x = "No entre uno 1 y 5"
```
</script></section><section data-markdown><script type="text/template">
### Guardas
</script></section><section data-markdown><script type="text/template">
Otra forma de analizar un valor entrada, es pidiendo que cumpla cierta _proposición_. Para ello usamos **guardas**.
</script></section><section data-markdown><script type="text/template">
Una guarda está compuesta por una expresión proposicional con la variable de entrada y un valor que retorna la función en caso de cumplirse. Al tener varias guardas, se analiza la primera, y si esta falla se continúa analizando la siguiente. Así hasta que alguna de verdadero.
</script></section><section data-markdown><script type="text/template">
```haskell
doubleSmallNumber x
    | x > 100 = x
    | otherwise = x * 2
```
</script></section><section data-markdown><script type="text/template">
## Práctica
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

### Funciones

- Declarar y definir las siguientes funciones

|Función|Explicación|
|:---|:---|
|seven|que dado cualquier valor, devuelve 7.|
|sign|que dado un entero devuelve 1 si es positivo, -1 si es negativo y 0 si es cero.|
|absolute|la función valor absoluto (usando la función **sign** y sin usarla)|
|and', or', not', xor'|las operaciones booleanas estándar, **sin utilizar las funciones predefinidas** en Haskell.|
|swap|toma un par ordenado, y devuelve un par ordenado con sus componentes en orden inverso|
<!-- .element: style="font-size: 25px" -->
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

- Reescribir las siguientes funciones sin el uso de let, where o if then else cuando sea
posible.

  - ```haskell
  f x = let (y,z) = (x,x) in y
  ```

  - ```haskell
  greaterThan (x,y) = if x > y
                          then True
                          else False
  ```

  - ```haskell
  f (x,y) = let z = x + y 
               in g (z,y) where g (a,b) = a - b
  ```
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

- Redefinir la función power4 de dos formas diferentes

```haskell
power4 x = let sqr y = y * y
            in sqr (sqr x)
```</script></section></section></div>
    </div>

    <script src="./lib/js/head.min.js"></script>
    <script src="./js/reveal.js"></script>

    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // Optional libraries used to extend on reveal.js
      var deps = [
        { src: './lib/js/classList.js', condition: function() { return !document.body.classList; } },
        { src: './plugin/markdown/marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
        { src: './plugin/markdown/markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
        { src: './plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
        { src: './plugin/zoom-js/zoom.js', async: true },
        { src: './plugin/notes/notes.js', async: true },
        { src: './plugin/math/math.js', async: true }
      ];

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        dependencies: deps
      };

      // options from URL query string
      var queryOptions = Reveal.getQueryHash() || {};

      var options = extend(defaultOptions, {}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
