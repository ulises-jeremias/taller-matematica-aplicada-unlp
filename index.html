<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Taller de Matemática Aplicada</title>
    <link rel="stylesheet" href="./css/reveal.css" />
    <link rel="stylesheet" href="./css/theme/solarized.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/atom-one-dark.css" />
    <link rel="stylesheet" href="./css/print/paper.css" type="text/css" media="print" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section ><section data-markdown><script type="text/template">

## Taller de
# Matemática Aplicada
</script></section><section data-markdown><script type="text/template">
## Docentes

-   Ulises Jeremias Cornejo Fandos
    _ucornejofandos@lifia.info.unlp.edu.ar_

-   Iván Mindlin
    <br />
    _mindlinster@gmail.com_
</script></section><section data-markdown><script type="text/template">
## Motivación
</script></section><section data-markdown><script type="text/template">
## Sobre el taller

- Taller de Matemática Aplicada
- Aplicamos conceptos vistos en la materia utilizando lenguajes de programación <!-- .element: class="fragment" -->
  - Haskell <!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
### Haskell

- Permite visualizar en forma más sencilla la solución a un determinado problema dada su similitud con el lenguaje matemático.
- Nos permite concentrarnos específicamente en el problema y su solución.
- A lo largo del taller conoceremos más sobre este lenguaje.
</script></section><section data-markdown><script type="text/template">
## Convenciones
</script></section><section data-markdown><script type="text/template">
### Equivalencia

Llamamos **Equivalencia** a como definimos en haskell las cosas que ya conocemos en Matemática.
</script></section><section data-markdown><script type="text/template">
## Plataforma de desarrollo

Para programar en este curso recomendamos las siguientes opciones:

- [Online Haskell Compiler](https://repl.it/languages/haskell)
- [Haskell Platform](https://www.haskell.org/platform)

</script></section></section><section ><section data-markdown><script type="text/template">
# Lógica
</script></section><section data-markdown><script type="text/template">
## Fundamento básicos
### Repaso
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

### Proposición

Oración declarativa a la cual se le puede asignar un valor verdad: _**verdadera (V)**_ o _**falsa (F)**_. 

Las proposiciones serán simbolizadas mediantes letras minúsculas: $p$, $q$, $r$, ...
</script></section><section data-markdown><script type="text/template">
### Ejercicios de repaso
</script></section><section data-markdown><script type="text/template">
_Determinar si los siguientes enunciados son proposiciones._

  - Siete es mayor que doce.
  - Si 6 > 4 entonces 6 > 2. <!-- .element: class="fragment" -->
  - Ella es inteligente. <!-- .element: class="fragment" -->
  - Quı́en es? <!-- .element: class="fragment" -->
  - En otros planetas del sistema solar hay diversos tipos de seres vivos. <!-- .element: class="fragment" -->
  - De 2 + 3 ≥ 5 + 4 se deduce 3 > 4. <!-- .element: class="fragment" -->
  - Estudiaré música o canto. <!-- .element: class="fragment" -->
  - Cualquier rectángulo tiene cuatro lados. <!-- .element: class="fragment" -->
  - x > 2. <!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

### Función proposicional

Dada una variable $x$ perteneciente al conjunto universal, se define una **función proposicional**, $p$, en la variable $x$, como un proceso que recibe $x$ y _**devuelve una proposión**_.

Una _proposición_ es una oración declarativa, _ó afirmación_, con un valor de verdad asociado.
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

En los lenguajes de programación no trabajamos con _"oraciones"_ como tal, sino que utilizamos directamente sus valores de verdad, es decir, Verdadero o Falso, _True_ o _False_, un **booleano** (Bool).
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

### Veamos unos ejemplos

-  2 es par
   **Verdadero** <!-- .element: class="fragment" -->
-  5 es par <!-- .element: class="fragment" -->
   **Falso** <!-- .element: class="fragment" -->
-  1 es par <!-- .element: class="fragment" -->
   **Falso** <!-- .element: class="fragment" -->


<div data-markdown>
    <br />

    <!-- .element: class="fragment" -->
    $p(x) = x$ es par, es una **función proposicional**. Por qué?
    
    <br />
    <br />

    El objetivo del taller es poder llevar los temas de la materia al ámbito de la computación. Para eso vamos a usar un lenguaje en particular, llamado **Haskell**.

    <br />
    <br />
</div>
</script></section><section data-markdown><script type="text/template">
## Introducción a Haskell
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

### Haskell

- Es un **lenguaje de programación funcional puro**.
- Lo utilizamos en el taller dado que presenta mayor relación con la matemática.
  - A diferencia de lenguajes imperativos como R-Info o Pascal.
- Esto permite escribir las ideas expresadas matemática, ó naturalmente, _directamente_ en el lenguaje de programación.
</script></section><section data-markdown><script type="text/template">
### ¿Cómo se expresan estas ideas?

Definiendo funciones.
</script></section><section data-markdown><script type="text/template">
Aunque después vamos a ver el concepto de función más formalmente en la materia, podemos dar una definición más natural:

<small class="fragment">
  Una _**función**_ es una caja que recibe uno, o más, elementos de un cierto _tipo_ y devuelve una sóla cosa de algún otro _tipo_. Es importante el concepto de que sólo se devuelve un único elemento.
</small>
</script></section><section data-markdown><script type="text/template">
En Haskell es muy útil e importante definir las funciones, así como en R-Info definían variables. Veamos como se declaran paso a paso.

<aside class="notes"><p>Mostrar en el pizarron paso a paso como declarar y definir una función.</p>
</aside></script></section><section data-markdown><script type="text/template">
<small>
  Esta función recibe un número entero (Int) y retorna el doble de ese número (Int).
</small>

```haskell
-- | double 2 = 4
-- | double 3 = 6
-- | double 4 = 8
-- | double (double 2) = ?
double :: Int -> Int
```
</script></section><section data-markdown><script type="text/template">Luego de declarar una función la definimos. Para esto podríamos decir cuánto vale la función para cada posible valor. Es importante que sólo podemos tener un resultado para un valor dado. Por ejemplo:
</script></section><section data-markdown><script type="text/template">

Algo que estaría **mal** es lo siguiente:

```haskell
double 2 = 4
double 2 = 3
```
</script></section><section data-markdown><script type="text/template">
No sólo porque no tiene ningún sentido si no que, por lo que mencionamos antes, **Una función NO puede tener dos resultados distintos para el mismo valor de entrada**.
</script></section><section data-markdown><script type="text/template">
### Definimos double

<small>
  Claramente, este trabajo de dar el valor para cada posible entrada es tedioso, así que la definimos como se puede ver a continuación:
</small>

```haskell
double :: Int -> Int
double x = 2 * x
```
<!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
### Problema

Una _función proposicional_, **¿qué tipo devuelve?** **¿qué recibe?**
</script></section><section data-markdown><script type="text/template">
### Función proposicional

Una funcion, en este caso proposicional, en Haskell debe declararse,

```haskell
p :: u -> Bool -- u es conjunto universal
```

- **u** representa al conjunto universal
- **-> Bool** quiere decir que devolveremos un valor de verdad, un _booleano_, es decir que los posibles resultados de la función son _True_ o _False_. _(En R-Info lo llamamos V y F)_
</script></section><section data-markdown><script type="text/template">
Para definir, e.g., la funcion proposional

_$r$($x$): $x$ es mayor que $0$_

lo hacemos de la siguiente forma:

```haskell
r :: Int -> Bool
r x = x > 0

-- donde x es cualquier valor perteneciente
-- a los Enteros, (Z), (Int).
```

<small>
  En las definicion anterior se pueden observar aspectos de haskell que iremos profundizando a medida que transcurre el taller.
</small>
</script></section><section data-markdown><script type="text/template">
### Equivalencias
## Operadores en Haskell
</script></section><section data-markdown><script type="text/template">
### Operadores Booleanos

```haskell
True && False   -- | AND lógico
True || False   -- | OR lógico
not True        -- | negación lógica
```
</script></section><section data-markdown><script type="text/template">
### Operadores Aritméticos

```haskell
2 + 3   -- | suma
3 - 2   -- | resta
4 * 2   -- | producto
1 / 2   -- | division
  .
  .
  .
```
</script></section><section data-markdown><script type="text/template">
## Operadores relacionales

```haskell
4 < 6    -- | menos que
3 <= 9   -- | menor o igual que
8 == 7   -- | igualdad
0 /= 1   -- | desigualdad
3 >= 2   -- | mayor o igual que
2 > 3    -- | mas que
```
</script></section><section data-markdown><script type="text/template">
## Problemas

Dadas las siguientes funciones proposicionales,

```haskell
-- Evalúa si un número divide a otro
-- divide (2, 4) = True
-- divide (3, 4) = False
divide :: (Int, Int) -> Bool

-- Evalúa si un número es par
-- esPar 2 = True
-- esPar 3 = False
esPar :: Int -> Bool
```
</script></section><section data-markdown><script type="text/template">
```haskell
divide :: (Int, Int) -> Bool
divide (d, x) = mod x d == 0

esPar :: Int -> Bool
esPar x = divide (2, x)
```
</script></section><section data-markdown><script type="text/template">
### Repasamos cosas de Haskell

```haskell
'c'   :: Char  -- caracter 'c' es de tipo Char
2     :: Int   -- 2 es de tipo Int, es decir, 2 pertenece a Z
True  :: Bool  -- True es de tipo Bool
False :: Bool  -- False es de tipo Bool
```
</script></section><section data-markdown><script type="text/template">
Definir las siguientes funciones

- $p$($n$): $n$ es par
- $q$($x$): $x$ es divisible por $2$
- $r$($x$): $x$ es igual $0$
- $c$($x$): $x$ es la letra 'c'
- $d$($y$): $y$ no es la letra 'c'
- $t$($x$, $y$): la suma entre $x$ e $y$ es igual a cero
- $w$($a$, $b$): $a$ es el opuesto de $b$
- $h$($n$, $m$): $n$ es igual a $0$ y $m$ no es la letra 'c'
- $a$($x$): 'x' es igual a 'x'
</script></section><section data-markdown><script type="text/template">
**SOLUCIONES**

```haskell
p :: Int -> Bool
p n = esPar n

q :: Int -> Bool
q x = divide (2, x)

r :: Int -> Bool
r x = x == 0

c :: Char -> Bool
c x = x == 'c'

d :: Char -> Bool
d x = not (c x)

t :: (Int, Int) -> Bool
t (x, y) = x + y == 0

w :: (Int, Int) -> Bool
w (a, b) = a == -b

h :: (Int, Char) -> Bool
h (n, m) = n == 0 && not (c m)

a :: u -> Bool
a x = True
```
</script></section></section><section ><section data-markdown><script type="text/template">
## Repaso
### Introducción a Haskell

<!-- .slide: style="text-align: left" -->

Esta sección del taller corresponde a la parte de Geometría de la materia. Sin embargo, por el momento vamos a seguir explorando Haskell así podemos utilizarlo para resolver problemas.
</script></section><section data-markdown><script type="text/template">
Para ello vamos a reforzar la idea de **Función** en _Haskell_.
</script></section><section data-markdown><script type="text/template">
Todas las funciones necesitan declararse. 

```haskell
toCelcius :: Int -> Float
```

Primero aclaramos qué función vamos a declarar y luego indicamos qué cosas recibe, y qué cosas devuelve.
</script></section><section data-markdown><script type="text/template">
En este caso recibe algo de Tipo **$u$** y devuelve algo de Tipo _**Bool**_. Pero...
</script></section><section data-markdown><script type="text/template">
### ¿Qué es un Tipo?

Cuando decimos que **algo es de un cierto tipo**, nos referimos a que ese _"algo"_ es un **valor qué pertenece a un determinado conjunto**. 

<small>
    Por ejemplo, cuando decimos que $x$ es de tipo Entero (_Int_ de Haskell), nos referimos a que los valores que puede tomar $x$ son valores enteros, es decir, $x$ pertenece al conjunto de los Enteros ($\mathcal{Z}$ matemático).
</small>
</script></section><section data-markdown><script type="text/template">
Las **expresiones** son formas de denotar un valor. Es decir el valor es una idea de lo que queremos representar, mientras que una expresión es la manera en la que "hablamos" de ese valor. 

<aside class="notes"><p>Anotar en el pizarrón a las expresiones apuntando a los valores que pertenecen a un cierto tipo</p>
</aside></script></section><section data-markdown><script type="text/template">
</script></section><section data-markdown><script type="text/template">
Luego, se define la función $toCelcius$ como sigue:

```haskell
toCelcius :: Int -> Float
toCelcius c = (c - 32)*(5/9)
```

<small>
    En este caso estamos diciendo que $toCelcius$ es una función que dado un $x$ entero devuelve un flotante, que es la temperatura en farenheit para la entrada c, temperatura en celcius
</small>
</script></section><section data-markdown><script type="text/template">
### ¿Cómo usamos esta función?

La aplicamos.
</script></section><section data-markdown><script type="text/template">
La aplicación es una de las operaciones que podemos realizar con una función. En haskell lo expresamos con un espacio `" "`.
</script></section><section data-markdown><script type="text/template">
Por ejemplo, lo que en matemática haríamos de esta forma, $toCelcius(82)$, en haskell es como sigue:

```haskell
r 82
-- 27.77777777777778
```

<small>
    aplicamos la función $toCelcius$ a un valor entero, $82$, obteniendo un valor de salida flotante, _27.77777777777778.
</small>
</script></section><section data-markdown><script type="text/template">
En terminos generales, podemos aplicar una función cualquiera a un valor cuyo **Tipo** sea el mismo que el **tipo de entrada** de la función. Y el resultado de la aplicación tendrá el tipo de salida de la misma.
</script></section><section data-markdown><script type="text/template">
En el ejemplo anterior

```haskell
toCelcius 82 :: Float
```
</script></section><section data-markdown><script type="text/template">
Nosotros hasta ahora habiamos visto el operador `::` al momento de declarar el tipo de las funciones. Sin embargo, en el ejemplo anterior, utilizamos `::` para indicar el tipo de _toCelcius 2_.
</script></section><section data-markdown><script type="text/template">
### Que pasó??

<small>
    En haskell, al igual que en matemática, no diferenciamos lo que son funciones de los que son los valores. Es decir, una **función es un valor** que, al igual que el resto de los valores, tiene un **tipo**.
</small>
</script></section><section data-markdown><script type="text/template">
En este caso, cuando indicamos 

```haskell
toCelcius :: Int -> Bool
```

estamos diciendo que el **tipo** de $r$ es _Int -> Bool_.

**Más adelante vamos a ver como podemos sacarle el jugo a esta hermosa propiedad.** <!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
## Geometría
</script></section></section></div>
    </div>

    <script src="./lib/js/head.min.js"></script>
    <script src="./js/reveal.js"></script>

    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // Optional libraries used to extend on reveal.js
      var deps = [
        { src: './lib/js/classList.js', condition: function() { return !document.body.classList; } },
        { src: './plugin/markdown/marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
        { src: './plugin/markdown/markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
        { src: './plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
        { src: './plugin/zoom-js/zoom.js', async: true },
        { src: './plugin/notes/notes.js', async: true },
        { src: './plugin/math/math.js', async: true }
      ];

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        dependencies: deps
      };

      // options from URL query string
      var queryOptions = Reveal.getQueryHash() || {};

      var options = extend(defaultOptions, {}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
