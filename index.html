<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Taller de Matemática Aplicada</title>
    <link rel="stylesheet" href="./css/reveal.css" />
    <link rel="stylesheet" href="./css/theme/solarized.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/atom-one-dark.css" />
    <link rel="stylesheet" href="./css/print/paper.css" type="text/css" media="print" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section ><section data-markdown><script type="text/template">

## Taller de
# Matemática Aplicada
</script></section><section data-markdown><script type="text/template">
## Docentes

-   Ulises Jeremias Cornejo Fandos
    _ucornejofandos@lifia.info.unlp.edu.ar_

-   Iván Mindlin
    <br />
    _mindlinster@gmail.com_
</script></section><section data-markdown><script type="text/template">
## Motivación
</script></section><section data-markdown><script type="text/template">
## Sobre el taller

- Taller de Matemática Aplicada
- Aplicamos conceptos vistos en la materia utilizando lenguajes de programación <!-- .element: class="fragment" -->
  - Haskell <!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
### Haskell

- Permite visualizar en forma más sencilla la solución a un determinado problema dada su similitud con el lenguaje matemático.
- Nos permite concentrarnos específicamente en el problema y su solución.
- A lo largo del taller conoceremos más sobre este lenguaje.
</script></section><section data-markdown><script type="text/template">
## Convenciones
</script></section><section data-markdown><script type="text/template">
### Equivalencia

Llamamos **Equivalencia** a como definimos en haskell las cosas que ya conocemos en Matemática.
</script></section><section data-markdown><script type="text/template">
## Plataforma de desarrollo

Para programar en este curso recomendamos las siguientes opciones:

- [Online Haskell Compiler](https://repl.it/languages/haskell)
- [Haskell Platform](https://www.haskell.org/platform)

</script></section></section><section ><section data-markdown><script type="text/template">
# Lógica
</script></section><section data-markdown><script type="text/template">
## Fundamento básicos
### Repaso
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

### Proposición

Oración declarativa a la cual se le puede asignar un valor verdad: _**verdadera (V)**_ o _**falsa (F)**_. 

Las proposiciones serán simbolizadas mediantes letras minúsculas: $p$, $q$, $r$, ...
</script></section><section data-markdown><script type="text/template">
### Ejercicios de repaso
</script></section><section data-markdown><script type="text/template">
_Determinar si los siguientes enunciados son proposiciones._

  - Siete es mayor que doce.
  - Si 6 > 4 entonces 6 > 2. <!-- .element: class="fragment" -->
  - Ella es inteligente. <!-- .element: class="fragment" -->
  - Quı́en es? <!-- .element: class="fragment" -->
  - En otros planetas del sistema solar hay diversos tipos de seres vivos. <!-- .element: class="fragment" -->
  - De 2 + 3 ≥ 5 + 4 se deduce 3 > 4. <!-- .element: class="fragment" -->
  - Estudiaré música o canto. <!-- .element: class="fragment" -->
  - Cualquier rectángulo tiene cuatro lados. <!-- .element: class="fragment" -->
  - x > 2. <!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

### Función proposicional

Dada una variable $x$ perteneciente al conjunto universal, se define una **función proposicional**, $p$, en la variable $x$, como un proceso que recibe $x$ y _**devuelve una proposión**_.

Una _proposición_ es una oración declarativa, _ó afirmación_, con un valor de verdad asociado.
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

En los lenguajes de programación no trabajamos con _"oraciones"_ como tal, sino que utilizamos directamente sus valores de verdad, es decir, Verdadero o Falso, _True_ o _False_, un **booleano** (Bool).
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

### Veamos unos ejemplos

-  2 es par
   **Verdadero** <!-- .element: class="fragment" -->
-  5 es par <!-- .element: class="fragment" -->
   **Falso** <!-- .element: class="fragment" -->
-  1 es par <!-- .element: class="fragment" -->
   **Falso** <!-- .element: class="fragment" -->


<div data-markdown>
    <br />

    <!-- .element: class="fragment" -->
    $p(x) = x$ es par, es una **función proposicional**. Por qué?
    
    <br />
    <br />

    El objetivo del taller es poder llevar los temas de la materia al ámbito de la computación. Para eso vamos a usar un lenguaje en particular, llamado **Haskell**.

    <br />
    <br />
</div>
</script></section><section data-markdown><script type="text/template">
## Introducción a Haskell
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

### Haskell

- Es un **lenguaje de programación funcional puro**.
- Lo utilizamos en el taller dado que presenta mayor relación con la matemática.
  - A diferencia de lenguajes imperativos como R-Info o Pascal.
- Esto permite escribir las ideas expresadas matemática, ó naturalmente, _directamente_ en el lenguaje de programación.
</script></section><section data-markdown><script type="text/template">
### ¿Cómo se expresan estas ideas?

Definiendo funciones.
</script></section><section data-markdown><script type="text/template">
Aunque después vamos a ver el concepto de función más formalmente en la materia, podemos dar una definición más natural:

<small class="fragment">
  Una _**función**_ es una caja que recibe uno, o más, elementos de un cierto _tipo_ y devuelve una sóla cosa de algún otro _tipo_. Es importante el concepto de que sólo se devuelve un elemento.
</small>
</script></section><section data-markdown><script type="text/template">
En Haskell es muy útil e importante declarar las funciones, así como en R-Info se definían variables. Veamos como se declaran y definen paso a paso.

<aside class="notes"><p>Mostrar en el pizarron paso a paso como declarar y definir una función.</p>
</aside></script></section><section data-markdown><script type="text/template">
<small>
  Esta función recibe un número entero (Int) y retorna el doble de ese número (Int).
</small>

```haskell
-- | double 2 = 4
-- | double 3 = 6
-- | double 4 = 8
-- | double (double 2) = ?
double :: Int -> Int
```
</script></section><section data-markdown><script type="text/template">Luego de declarar una función la definimos. Para esto podríamos decir cuánto vale la función para cada posible valor. Es importante que sólo podemos tener un resultado para un valor dado. Por ejemplo:
</script></section><section data-markdown><script type="text/template">

Algo que estaría **mal** es lo siguiente:

```haskell
double 2 = 4
double 2 = 3
```
</script></section><section data-markdown><script type="text/template">
No sólo porque no tiene ningún sentido si no que, por lo que mencionamos antes, **Una función NO puede tener dos resultados distintos para el mismo valor de entrada**.
</script></section><section data-markdown><script type="text/template">
### Definimos double

<small>
  Claramente, este trabajo de dar el valor para cada posible entrada es tedioso, así que la definimos como se puede ver a continuación:
</small>

```haskell
double :: Int -> Int
double x = 2 * x
```
<!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
### Problema

Una _función proposicional_, **¿qué tipo devuelve?** **¿qué recibe?**
</script></section><section data-markdown><script type="text/template">
### Función proposicional

Una funcion, en este caso proposicional, en Haskell debe declararse,

```haskell
p :: u -> Bool -- u es conjunto universal
```

- **u** representa al conjunto universal
- **-> Bool** quiere decir que devolveremos un valor de verdad, un _booleano_, es decir que los posibles resultados de la función son _True_ o _False_. _(En R-Info lo llamamos V y F)_
</script></section><section data-markdown><script type="text/template">
Para definir, e.g., la funcion proposional

_$r$($x$): $x$ es mayor que $0$_

lo hacemos de la siguiente forma:

```haskell
r :: Int -> Bool
r x = x > 0

-- donde x es cualquier valor perteneciente
-- a los Enteros, (Z), (Int).
```

<small>
  En las definicion anterior se pueden observar aspectos de haskell que iremos profundizando a medida que transcurre el taller.
</small>
</script></section><section data-markdown><script type="text/template">
### Equivalencias
## Operadores en Haskell
</script></section><section data-markdown><script type="text/template">
### Operadores Booleanos

```haskell
True && False   -- | AND lógico
True || False   -- | OR lógico
not True        -- | negación lógica
```
</script></section><section data-markdown><script type="text/template">
### Operadores Aritméticos

```haskell
2 + 3   -- | suma
3 - 2   -- | resta
4 * 2   -- | producto
1 / 2   -- | division
  .
  .
  .
```
</script></section><section data-markdown><script type="text/template">
## Operadores relacionales

```haskell
4 < 6    -- | menos que
3 <= 9   -- | menor o igual que
8 == 7   -- | igualdad
0 /= 1   -- | desigualdad
3 >= 2   -- | mayor o igual que
2 > 3    -- | mas que
```
</script></section><section data-markdown><script type="text/template">
## Problemas

Dadas las siguientes funciones proposicionales,

```haskell
-- Evalúa si un número divide a otro
-- divide (2, 4) = True
-- divide (3, 4) = False
divide :: (Int, Int) -> Bool

-- Evalúa si un número es par
-- esPar 2 = True
-- esPar 3 = False
esPar :: Int -> Bool
```
</script></section><section data-markdown><script type="text/template">
```haskell
divide :: (Int, Int) -> Bool
divide (d, x) = mod x d == 0

esPar :: Int -> Bool
esPar x = divide (2, x)
```
</script></section><section data-markdown><script type="text/template">
### Repasamos cosas de Haskell

```haskell
'c'   :: Char  -- caracter 'c' es de tipo Char
2     :: Int   -- 2 es de tipo Int, es decir, 2 pertenece a Z
True  :: Bool  -- True es de tipo Bool
False :: Bool  -- False es de tipo Bool
```
</script></section><section data-markdown><script type="text/template">
Definir las siguientes funciones

- $p$($n$): $n$ es par
- $q$($x$): $x$ es divisible por $2$
- $r$($x$): $x$ es igual $0$
- $c$($x$): $x$ es la letra 'c'
- $d$($y$): $y$ no es la letra 'c'
- $t$($x$, $y$): la suma entre $x$ e $y$ es igual a cero
- $w$($a$, $b$): $a$ es el opuesto de $b$
- $h$($n$, $m$): $n$ es igual a $0$ y $m$ no es la letra 'c'
- $a$($x$): 'x' es igual a 'x'
</script></section><section data-markdown><script type="text/template">
**SOLUCIONES**

```haskell
p :: Int -> Bool
p n = esPar n

q :: Int -> Bool
q x = divide (2, x)

r :: Int -> Bool
r x = x == 0

c :: Char -> Bool
c x = x == 'c'

d :: Char -> Bool
d x = not (c x)

t :: (Int, Int) -> Bool
t (x, y) = x + y == 0

w :: (Int, Int) -> Bool
w (a, b) = a == -b

h :: (Int, Char) -> Bool
h (n, m) = n == 0 && not (c m)

a :: u -> Bool
a x = True
```
</script></section></section><section ><section data-markdown><script type="text/template">
# Geometría
</script></section><section data-markdown><script type="text/template">
## Repaso
### Introducción a Haskell

<!-- .slide: style="text-align: left" -->

Esta sección del taller corresponde a la parte de Geometría de la materia. Sin embargo, por el momento vamos a seguir explorando Haskell así podemos utilizarlo para resolver problemas.
</script></section><section data-markdown><script type="text/template">
Para ello vamos a reforzar la idea de **Función** en _Haskell_.
</script></section><section data-markdown><script type="text/template">
Todas las funciones necesitan declararse. 

```haskell
-- Fahrenheit to Celsius
ftc :: Float -> Float
```

Primero aclaramos qué función vamos a declarar y luego indicamos qué cosas recibe, y qué cosas devuelve.
</script></section><section data-markdown><script type="text/template">
En este caso recibe algo de Tipo _**Int**_ y devuelve algo de Tipo _**Float**_. Pero...
</script></section><section data-markdown><script type="text/template">
### ¿Qué es un Tipo?

Cuando decimos que **algo es de un cierto tipo**, nos referimos a que ese _"algo"_ es un **valor qué pertenece a un determinado conjunto**. 

<small>
    Por ejemplo, cuando decimos que $x$ es de tipo Entero (_Int_ de Haskell), nos referimos a que los valores que puede tomar $x$ son valores enteros, es decir, $x$ pertenece al conjunto de los Enteros ($\mathcal{Z}$ matemático).
</small>

<aside class="notes"><p>Anticipar idea de expresión indicando lo importante que es cómo <em>denotar</em> un valor.</p>
</aside></script></section><section data-markdown><script type="text/template">
Las **expresiones** son formas de denotar un valor. Es decir el valor es una idea de lo que queremos representar, mientras que una expresión es la manera en la que _hablamos_ de ese valor. 

<aside class="notes"><p>Anotar en el pizarrón a las expresiones apuntando a los valores que pertenecen a un cierto tipo</p>
</aside></script></section><section data-markdown><script type="text/template">
Luego, se define la función $ftc$ como sigue:

```haskell
ftc :: Float -> Float
ftc x = (x - 32) * 5 / 9
```

<small>
    En este caso estamos diciendo que $ftc$ es una función que dado un $x$ flotante devuelve un flotante, que es la temperatura en celsius para la entrada x en fahrenheit.
</small>
</script></section><section data-markdown><script type="text/template">
### ¿Cómo usamos esta función?

La aplicamos.
</script></section><section data-markdown><script type="text/template">
La aplicación es una de las operaciones que podemos realizar con una función. En haskell lo expresamos con un espacio `" "`.
</script></section><section data-markdown><script type="text/template">
Por ejemplo, lo que en matemática haríamos de esta forma, $ftc(82)$, en haskell es como sigue:

```haskell
r 82.0
-- 27.77777777777778
```

<small>
    aplicamos la función $ftc$ a un valor entero, $82$, obteniendo un valor de salida flotante, _27.77777777777778_.
</small>
</script></section><section data-markdown><script type="text/template">
En terminos generales, podemos aplicar una función cualquiera a un valor cuyo **Tipo** sea el mismo que el **tipo de entrada** de la función. Y el resultado de la aplicación tendrá el tipo de salida de la misma.
</script></section><section data-markdown><script type="text/template">
En el ejemplo anterior

```haskell
ftc 82.0 :: Float
```
</script></section><section data-markdown><script type="text/template">
Como se habrán dado cuenta, el símbolo :: lo hemos utilizado para declarar una función, pero también para decir el tipo de _2.0_ , 'C', o incluso _ftc 2.0_ ¿Qué nos sugiere esto?
</script></section><section data-markdown><script type="text/template">
En haskell, al igual que en matemática, no diferenciamos lo que son funciones de los que son los valores. Es decir, una **función es un valor** que, al igual que el resto de los valores, tiene un **tipo**.
</script></section><section data-markdown><script type="text/template">
En este caso, cuando indicamos 

```haskell
ftc :: Float -> Float
```

estamos diciendo que el **tipo** de $ftc$ es _Float -> Float_ ¿Y esto qué implica? Si las funciones son "procesos" que reciben algo de un cierto tipo y devuelven otra cosa de un cierto tipo, y las funciones tienen un tipo, tiene sentido que una función pueda **recibir una función como parámetro de entrada**. Veamos cómo nos ayuda esto en la siguiente sección.

</script></section><section data-markdown><script type="text/template"><!-- .slide: style="text-align: left" -->

### Repaso
## Problemas

Escribir expresiones que tengan los siguientes tipos

-  (Int, Int)
-  Float
-  Char
-  Int -> Int
-  Bool -> (Bool, Bool)
</script></section><section data-markdown><script type="text/template">
## Geometría

<small>
    Existen situaciones en las cuales es conveniente expresar un problema a traves de un plano coordenado. Este se compone de dos ejes que representan dos variables. Por ejemplo el crecimiento de una población en función del tiempo.
</small>

<img src="../static/worldGrowth.png" alt="Imagen poblacion" width="250" height="250">

Caso de estudio: _Tenemos una variable, cuyo valor depende de otra variable_.
</script></section><section data-markdown><script type="text/template">
Expresemos, por ejemplo, la superficie de un terreno en función de uno de sus lados.

<aside class="notes"><p>Escribir el problema matemáticamente, y después en Haskell</p>
</aside></script></section><section data-markdown><script type="text/template">
Sabemos que un punto es un dato en el plano al cual le podemos atribuir un valor, por lo tanto, podemos definir funciones como las siguientes:

```haskell
abscisa :: (Float, Float) -> Float
```

```haskell
abscisa (x, y) = x
```
<!-- .element: class="fragment" -->

```haskell
ordenada :: (Float, Float) -> Float
```

```haskell
ordenada (x, y) = y
```
<!-- .element: class="fragment" -->

<aside class="notes"><p>preguntar cómo es</p>
</aside></script></section><section data-markdown><script type="text/template">
Supongamos que queremos sumar dos puntos. La suma entre dos puntos la definiremos de la siguiente forma:

```
Sean P = (a, b), Q = (c, d),

P + Q = (a + c, b + d)
```

<aside class="notes"><p>Hablar sobre recibir varios parámetros en una función</p>
</aside></script></section><section data-markdown><script type="text/template">
Cuando querramos recibir varios parámetros declararemos la función de la siguiente manera: 

*a0 -> a1 -> a2*

Donde *a0* y *a1* son los tipos de entrada, y *a2* es el tipo de salida. _En general_, siempre el último tipo indicado es el tipo de salida. Pero ¿No era que las funciones recibían una cosa y devolvían otra? ¿Una función puede recibir más de una cosa? *Ya veremos...*
</script></section><section data-markdown><script type="text/template">
### Regiones en el plano

Hagamos una función que nos diga si un punta dado *p* pertenece a una cierta región *r*.
</script></section><section data-markdown><script type="text/template">
### Rectas

Una recta es una relación entre dos valores, uno del eje X y otro del eje Y. Entonces es una función y por lo tanto podemos aplicar todas las propiedades que venimos trabajando hasta ahora. 

<aside class="notes"><p>Hacer que definan una función que me diga si un punta dado está en la recta</p>
</aside></script></section><section data-markdown><script type="text/template">
A veces nos da mayor legibilidad guardar ciertas ideas en variables. 

**Equivalencia**: Así como en matémica decimos "Sea x una variable real" o "Donde f es una función" en haskell tenemos las cláusulas _**let in**_ y _**where**_

<aside class="notes"><p>Habría que explicar el <em>let in</em>, y el <em>where</em></p>
</aside></script></section><section data-markdown><script type="text/template">
**let in**

Cláusula con la forma general:

```haskell
let x1 = e1
    x2 = e2
--  ...
--  xn = en
in expresionQueUsaLasVariables
```
</script></section><section data-markdown><script type="text/template">
**where**

Cláusula con la forma general:

```haskell
expresionQueUsa x1 x2 ... xn
	where x1 = e1
	      x2 = e2
	      ...
	      xn = en
```
</script></section><section data-markdown><script type="text/template">
</script></section></section><section ><section data-markdown><script type="text/template">
# HASKELL
</script></section><section data-markdown><script type="text/template">
## Repaso
# Rápido <!-- .element: class="fragment"-->
</script></section><section data-markdown><script type="text/template">
### Operadores Aritméticos

```haskell
ghci> 2 + 15  
17  
ghci> 49 * 100  
4900  
ghci> 1892 - 1472  
420  
ghci> 5 / 2  
2.5  
ghci>
```
</script></section><section data-markdown><script type="text/template">
#### Operadores Aritméticos combinados

```haskell
ghci> (50 * 100) - 4999  
1  
ghci> 50 * 100 - 4999  
1  
ghci> 50 * (100 - 4999)  
-244950
ghci>
```
</script></section><section data-markdown><script type="text/template">
### Operadores Booleanos

```haskell
ghci> True && False  
False  
ghci> True && True  
True  
ghci> False || True  
True   
ghci> not False  
True  
ghci> not (True && True)  
False
ghci>
```
</script></section><section data-markdown><script type="text/template">
### Igualdad

```haskell
ghci> 5 == 5  
True  
ghci> 1 == 0  
False  
ghci> 5 /= 5  
False  
ghci> 5 /= 4  
True  
ghci> "hello" == "hello"  
True
ghci>
```
</script></section><section data-markdown><script type="text/template">
## Definimos Funciones

```haskell
doubleMe x = x + x 
```
</script></section><section data-markdown><script type="text/template">
## Aplicamos Funciones

```haskell
ghci> doubleMe 9  
18  
ghci> doubleMe 8.3  
16.6
ghci>
```
</script></section><section data-markdown><script type="text/template">
## Funciones con más de un parámetro

```haskell
doubleUs x y = x*2 + y*2 
```
</script></section><section data-markdown><script type="text/template">
## Aplicamos

```haskell
ghci> doubleUs 4 9  
26  
ghci> doubleUs 2.3 34.2  
73.0  
ghci> doubleUs 28 88 + doubleMe 123  
478
ghci
```
</script></section><section data-markdown><script type="text/template">
## Reutilizamos definiciones

```haskell
-- doubleMe x = x + x
-- doubleUs x y = x*2 + y*2
doubleUs x y = doubleMe x + doubleMe y 
```
</script></section><section data-markdown><script type="text/template">
## Funciones partidas. Cómo?
</script></section><section data-markdown><script type="text/template">
```haskell
doubleSmallNumber x = if x > 100  
                        then x
                        else x * 2  
```
</script></section><section data-markdown><script type="text/template">
```haskell
-- doubleSmallNumber' x = (doubleSmallNumber x) + 1
doubleSmallNumber' x = (if x > 100 then x else x * 2) + 1
```
</script></section><section data-markdown><script type="text/template">
## Sintaxis en Funciones
</script></section><section data-markdown><script type="text/template">
### Pattern Matching

Consiste en una especificación de pautas que deben ser seguidas por los datos, los cuales pueden ser deconstruidos permitiéndonos acceder a sus componentes.

<img src="../static/meme_negro_confundido.jpg" class="fragment" alt="Imagen poblacion">
</script></section><section data-markdown><script type="text/template">
Llevandolo a lo que conocemos hasta ahora... Cuando nosotros definiamos una función planteabamos casos de ejemplo para guiarnos al buscar un término general.

```haskell
-- doubleMe 2 = 4
-- doubleMe 3 = 6
-- doubleMe 4 = 8
doubleMe x = x + x
```
</script></section><section data-markdown><script type="text/template">
Pero, **¿Qué pasa si uno de los casos no puede obtenerse con el caso general?**
</script></section><section data-markdown><script type="text/template">
Para eso nos sirve el **Pattern Matching**, para definir casos en base al parámetro de entrada!!
</script></section><section data-markdown><script type="text/template">
```haskell
lucky :: Int -> String
lucky 7 = "Uyy, un sieteeee ¡Genial!"
lucky x = "Meh, no me interesa"
```
</script></section><section data-markdown><script type="text/template">
Cuando llamamos a **lucky**, los patrones son verificados de arriba a abajo y cuando un patrón concuerda con el valor asociado, se utiliza el cuerpo de la función asociado. 

En este caso, la única forma de que un número concuerde con el primer patrón es que dicho número sea 7. Si no lo es,se evaluara el siguiente patrón, el cual coincide con cualquier valor y lo liga a x.
</script></section><section data-markdown><script type="text/template">
También se podría haber implementado utilizando una sentencia **if**. Pero, ¿qué pasaría si quisiéramos una función que nombrara los número del 1 al 5, o "No entre uno 1 y 5" para cualquier otro número?

Si no tuviéramos el ajuste de patrones deberíamos escribir una gran cantidad de **if then else**. Sin embargo con él:
</script></section><section data-markdown><script type="text/template">
```haskell
sayMe :: Int -> String
sayMe 1 = "Uno"
sayMe 2 = "Dos"
sayMe 3 = "Tres"
sayMe 4 = "Cuatro"
sayMe 5 = "Cinco"
sayMe x = "No entre uno 1 y 5"
```
</script></section><section data-markdown><script type="text/template">
### Guardas
</script></section><section data-markdown><script type="text/template">
Otra forma de analizar un valor entrada, es pidiendo que cumpla cierta _proposición_. Para ello usamos **guardas**.
</script></section><section data-markdown><script type="text/template">
Una guarda está compuesta por una expresión proposicional con la variable de entrada y un valor que retorna la función en caso de cumplirse. Al tener varias guardas, se analiza la primera, y si esta falla se continúa analizando la siguiente. Así hasta que alguna de verdadero.
</script></section><section data-markdown><script type="text/template">
```haskell
doubleSmallNumber x
    | x > 100 = x
    | otherwise = x * 2
```
</script></section><section data-markdown><script type="text/template">
## Práctica
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

### Funciones

- Declarar y definir las siguientes funciones

|Función|Explicación|
|:---|:---|
|seven|que dado cualquier valor, devuelve 7.|
|sign|que dado un entero devuelve 1 si es positivo, -1 si es negativo y 0 si es cero.|
|absolute|la función valor absoluto (usando la función **sign** y sin usarla)|
|and', or', not', xor'|las operaciones booleanas estándar, **sin utilizar las funciones predefinidas** en Haskell.|
|swap|toma un par ordenado, y devuelve un par ordenado con sus componentes en orden inverso|
<!-- .element: style="font-size: 25px" -->
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

- Reescribir las siguientes funciones sin el uso de let, where o if then else cuando sea
posible.

  - ```haskell
  f x = let (y,z) = (x,x) in y
  ```

  - ```haskell
  greaterThan (x,y) = if x > y
                          then True
                          else False
  ```

  - ```haskell
  f (x,y) = let z = x + y 
               in g (z,y) where g (a,b) = a - b
  ```
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

- Redefinir la función power4 de dos formas diferentes

```haskell
power4 x = let sqr y = y * y
            in sqr (sqr x)
```
</script></section></section><section ><section data-markdown><script type="text/template">
# CONJUNTOS
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

## Conjunto

Un **conjunto** es una colección de elementos con características similares considerada en sí misma como un objeto.

Se dice que un elemento (o miembro) pertenece al conjunto si está definido como incluido de algún modo dentro de él.
</script></section><section data-markdown><script type="text/template">
Un conjunto suele definirse mediante una **propiedad que todos sus elementos poseen**. Por ejemplo, para los _números naturales_, si se considera la propiedad de ser un número primo, el conjunto de los números primos es:

$P = \{2, 3, 5, 7, 11, 13, \ldots \}$
</script></section><section data-markdown><script type="text/template">
Conocer las distintas propiedades y operaciones que se pueden aplicar a conjuntos nos permite introducir el siguiente concepto de Haskell.
</script></section><section data-markdown><script type="text/template">
# Listas

<aside class="notes"><p>Mostrar operaciones básicas como funciones.</p>
</aside></script></section><section data-markdown><script type="text/template">
En esta clase vamos a ver algunos de los conceptos más importantes del taller:

-  Bases sobre las listas
-  Cadenas de texto
-  **Listas**
</script></section><section data-markdown><script type="text/template">
En Haskell, las listas son una estructura **homogénea**. Almacena varios elementos del mismo tipo. 

<small>
    Esto significa que podemos crear una lista de enteros o una lista de caracteres, pero no podemos crear una lista que tenga unos cuantos enteros y otros cuantos caracteres.
</small>
</script></section><section data-markdown><script type="text/template">
```haskell
ghci> let lostNumbers = [4, 8, 15, 16, 23, 42]
ghci> lostNumbers
[4, 8, 15, 16, 23, 42]
```

<small>
    Las listas se definen mediante corchetes y sus valores se separan por comas.
</small>
</script></section><section data-markdown><script type="text/template">
En general, se escribe entre '[' y ']' y sus elementos separados por ','

```haskell
[1, 2, 3]
[True,  True, False]
['y', 'o', 'l', 'o']
```
</script></section><section data-markdown><script type="text/template">
```haskell
[1, 2, 'a', 3, 'b', 'c', 4]
```

<small>
    Si intentáramos crear una lista como esta Haskell nos avisaría que los caracteres no son números.
</small>
</script></section><section data-markdown><script type="text/template">
Las cadenas de texto son listas de caracteres.

```haskell
"hello"
['h', 'e', 'l', 'l', 'o']
```
</script></section><section data-markdown><script type="text/template">
Tipo de una lista

```haskell
[2,3,4] :: [Int]
['a', 'b', 'c'] :: [Char]
```
</script></section><section data-markdown><script type="text/template">
## Tipo de [ ] ??

`[] :: [a]` <!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
Dos operaciones básicas que podemos realizar con ellas son:

```haskell
(++) :: [a] -> [a] -> [a]
-- función que concatena dos listas

(:) :: a -> [a] -> [a]
-- función que agrega un elemento al principio de la lista
```
</script></section><section data-markdown><script type="text/template">
### Concatenación

```haskell
ghci> [1,2,3,4] ++ [9,10,11,12]
[1,2,3,4,9,10,11,12]
ghci> "hello" ++ " " ++ "world"
"hello world"
ghci> ['w','o'] ++ ['o','t']
"woot"
```
</script></section><section data-markdown><script type="text/template">
### Cons

```haskell
ghci> 'U':"n gato negro"
"Un gato negro"
ghci> 5:[1,2,3,4,5]
[5,1,2,3,4,5]
```
</script></section><section data-markdown><script type="text/template">
`[1,2,3]` es una alternativa sintáctica de `1:2:3:[]`. 

-  `[]` es una lista vacía. Si anteponemos 3 a ella con `:`, obtenemos `[3]`, y si anteponemos 2 a esto obtenemos `[2,3]`.

<aside class="notes"><p>Desambiguar listas vacias</p>
</aside></script></section><section data-markdown><script type="text/template">
`[], [[]] y [[],[],[]]`
</script></section><section data-markdown><script type="text/template">
## Funciones básicas sobre listas
</script></section><section data-markdown><script type="text/template">
### Head

Toma una lista y devuelve su cabeza. La cabeza de una lista es básicamente el primer elemento.

```haskell
ghci> head [5, 4, 3, 2, 1]
5
```
</script></section><section data-markdown><script type="text/template">
### Tail

Toma una lista y devuelve su cola. En otros palabras,  corta la cabeza de la lista.

```haskell
ghci> tail [5, 4, 3, 2, 1]
[4, 3, 2, 1]
```
</script></section><section data-markdown><script type="text/template">
### Last

Toma una lista y devuelve su último elemento.

```haskell
ghci> last [5, 4, 3, 2, 1]
1
```
</script></section><section data-markdown><script type="text/template">
### Init

Toma una lista y devuelve toda la lista excepto su último elemento.

```haskell
ghci> init [5, 4, 3, 2, 1]
[5, 4, 3, 2]
```
</script></section><section data-markdown><script type="text/template">
### Length

Toma una lista y obviamente devuelve su tamaño.

```haskell
ghci> length [5,4,3,2,1]
5
```
</script></section><section data-markdown><script type="text/template">
### Null

Comprueba si una lista está vacía. Si lo está, devuelve True, en caso contrario devuelve False. Usa esta función en lugar de xs == [] (si tienes una lista que se llame xs).

```haskell
ghci> null [1,2,3]
False
ghci> null []
True
reverse pone del revés una lista.
ghci> reverse [5,4,3,2,1]
[1,2,3,4,5]
```</script></section><section data-markdown><script type="text/template">
### take

Toma un número y una lista y extrae dicho número de elementos de una lista. Observa.

```haskell
ghci> take 3 [5,4,3,2,1]
[5,4,3]
ghci> take 1 [3,9,3]
[3]
ghci> take 5 [1,2]
[1,2]
ghci> take 0 [6,6,6]
[]
```

Si intentamos tomar más elementos de los que hay en una lista, simplemente devuelve la lista. Si tomamos 0 elementos, obtenemos una lista vacía.
</script></section><section data-markdown><script type="text/template">### Drop

Funciona de forma similar, solo que quita un número de elementos del comienzo de la lista.

```haskell
ghci> drop 3 [8,4,2,1,5,6]
[1,5,6]
ghci> drop 0 [1,2,3,4]
[1,2,3,4]
ghci> drop 100 [1,2,3,4]
[]
```
</script></section><section data-markdown><script type="text/template">
### Maximum y minimun

Maximun toma una lista de cosas que se pueden poner en algún tipo de orden y devuelve el elemento más grande. Minimum devuelve el más pequeño.

```haskell
ghci> minimum [8,4,2,1,5,6]
1
ghci> maximum [1,9,2,3,4]
9
```</script></section><section data-markdown><script type="text/template">
### sum

Toma una lista de números y devuelve su suma.
product toma una lista de números y devuelve su producto.

```haskell
ghci> sum [5,2,1,6,3,2,5,7]
31
ghci> product [6,2,1,2]
24
ghci> product [1,2,5,6,7,9,2,0]
0
```
</script></section><section data-markdown><script type="text/template">
### Elem

Toma una cosa y una lista de cosas y nos dice si dicha cosa es un elemento de la lista. Normalmente, esta función es llamada de forma infija porque resulta más fácil de leer.

```haskell
ghci> 4 `elem` [3,4,5,6]
True
ghci> 10 `elem` [3,4,5,6]
False
```
</script></section><section data-markdown><script type="text/template">
## Rangos
</script></section><section data-markdown><script type="text/template">
### Ejemplo

```haskell
ghci> [1..20]
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
ghci> ['a'..'z']
"abcdefghijklmnopqrstuvwxyz"
ghci> ['K'..'Z']
"KLMNOPQRSTUVWXYZ"
```
</script></section><section data-markdown><script type="text/template">
```haskell
ghci> [2,4..20]
[2,4,6,8,10,12,14,16,18,20]
ghci> [3,6..20]
[3,6,9,12,15,18]
```
</script></section><section data-markdown><script type="text/template">
```haskell
ghci> [0.1, 0.3 .. 1]
[0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
```

Consejo: No utilizar rangos con números en coma flotante.
</script></section><section data-markdown><script type="text/template">
## Listas por Comprensión
</script></section><section data-markdown><script type="text/template">
Si quisiéramos escribir esto en Haskell, podríamos usar algo como 

```haskell
take 10 [2, 4 ..]
```

<small>
    Pero, ¿y si no quisiéramos los dobles de los diez primeros número naturales, sino algo más complejo?
</small>
</script></section><section data-markdown><script type="text/template">
```haskell
ghci> [x*2 | x <- [1..10]]
[2,4,6,8,10,12,14,16,18,20]
```
</script></section><section data-markdown><script type="text/template">
**Agregando condiciones**

```haskell
ghci> [x*2 | x <- [1..10], x*2 >= 12]
[12,14,16,18,20]
```
</script></section><section data-markdown><script type="text/template">
```haskell
ghci> [ x*y | x <- [2,5,10], y <- [8,10,11]]
[16,20,22,40,50,55,80,100,110]
```
</script></section><section data-markdown><script type="text/template">
```haskell
ghci> [ x*y | x <- [2,5,10], y <- [8,10,11], x*y > 50]
[55,80,100,110]
```
</script></section><section data-markdown><script type="text/template">
### Length
</script></section><section data-markdown><script type="text/template">
```haskell
length' :: [a] -> Int
length' xs = ...
```
</script></section><section data-markdown><script type="text/template">
```haskell
length' :: [a] -> Int
length' xs = sum [ 1 | _ <- xs ]
```
</script></section></section><section ><section data-markdown><script type="text/template">
# Recursión
</script></section><section data-markdown><script type="text/template">
Antes de ver este tema vamos a revisar un concepto muy importante:
</script></section><section data-markdown><script type="text/template">
## Ejemplo
</script></section><section data-markdown><script type="text/template">
```haskell
inf :: Int
inf = 1 + inf
```
<!-- .element: contenteditable="true" -->
</script></section><section data-markdown><script type="text/template">
```haskell
seven :: a -> Int
seven _ = 7

-- seven inf = ??
```
<!-- .element: contenteditable="true" -->
</script></section><section data-markdown><script type="text/template">
```haskell
fst :: (a, b) -> a
fst (x, _) = x

-- fst (0, inf) = ??
```
<!-- .element: contenteditable="true" -->
</script></section><section data-markdown><script type="text/template">
## Qué pasa??
</script></section><section data-markdown><script type="text/template">
### Denotacional vs Operacional
# Reducción
</script></section><section data-markdown><script type="text/template">
La reducción es un _sistema de reescritura_. Se usa en distintos ámbitos, pero la esencia es la misma: **Reemplazar subtérminos de una fórmula (o expresión) con otros términos**.
</script></section><section data-markdown><script type="text/template">
En nuestro caso queremos utilizar reducciones para llegar al valor de un expresión. En otras palabras, queremos **reducir** una *expresión* a su *valor*.
</script></section><section data-markdown><script type="text/template">
## ¿Cómo hacemos?
</script></section><section data-markdown><script type="text/template">
### ¿Hasta donde lo hacemos?
## ¡¿Se reduce infinitamente?!
</script></section><section data-markdown><script type="text/template">
Veamos en el siguiente ejemplo cómo se reduce la expresión:

```haskell
seven inf
```
<!-- .element: contenteditable="true" -->
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

## Formas de Reducción

-  Forma normal

-  Formal aplicativa
</script></section><section data-markdown><script type="text/template">
## ¿Cual tiene haskell?

Ninguna de las anteriores <!-- .element: class="fragment" -->
</script></section><section data-markdown><script type="text/template">
Para entender las decisiones de implementación del lenguaje vamos a definir unos conceptos claves:
</script></section><section data-markdown><script type="text/template">
## Reducción

-  Redex (reducible expression)
  -  subexpresión que coincide con una instancia del lado izquierdo de una ecuación

-  Forma normal
  Expresión que no contiene redexes

-  Mecanismo de Reducción
    1.  Localizar un redex
    2.  Reemplazarlo
    3.  Repetir hasta que la expresión esté en forma normal
</script></section><section data-markdown><script type="text/template">
-  Normalización
-  ¿La forma normal es única?
-  Ordenes de reducción
    -  ¿Hay una única forma de reducir? ¿Son todas equivalentes?
</script></section><section data-markdown><script type="text/template">
## Normalización

-  Forma normal
    -  Expresión que no se puede reducir
    -  _Valor_

-  No toda expresión tiene forma normal!
    -  e.g. **inf**
    -  Valor denotacional, _Bottom_
    -  Valor operacional
</script></section><section data-markdown><script type="text/template">
## Bottom

```haskell
bottom :: a
bottom = bottom
```
<!-- .element: contenteditable="true" -->
</script></section><section data-markdown><script type="text/template">
## Bottom y Funciones

-  Funciones Estrictas
-  Funciones NO Estrictas
</script></section><section data-markdown><script type="text/template">
## Funciones No Estrictas

```haskell
const :: a -> b -> a
const x _ = x

-- const 7 inf = ??
```
<!-- .element: contenteditable="true" -->
<small>
    Si la función precisa el valor de los parámetros para dar un resultado, entonces
    es estricta.
</small>
</script></section><section data-markdown><script type="text/template">
## Orden de Evaluación
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

### Orden APLICATIVO

Primero los redexes internos

-  Es decir, primero los argumentos y luego la aplicación
-  TODAS LAS FUNCIONES SON ESTRICTAS
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

### Orden NORMAL

Primeros los redexes externos

-  Primero la aplicación y, si aún están, los argumentos
-  Hay funciones estrictas y no estrictas
</script></section><section data-markdown><script type="text/template">
## Ejemplos
</script></section><section data-markdown><script type="text/template">
### Ejemplo 1

```haskell
quin x = x + x + x + x + x
```
<!-- .element: contenteditable="true" -->
<small>
    Sabemos que (fib 22) cuesta ~1.000.000 reducciones
</small>
</script></section><section data-markdown><script type="text/template">
```haskell
-- cuantas reducciones?
quin (fib 22)
```
<!-- .element: contenteditable="true" -->
</script></section><section data-markdown><script type="text/template">
### Ejemplo 2

```haskell
-- cuantas reducciones
const 3 (quin (fin 22))
```
<!-- .element: contenteditable="true" -->
</script></section><section data-markdown><script type="text/template">
## Y Haskell??
</script></section><section data-markdown><script type="text/template">
# Lazy Evaluation
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

### Lazy Evaluation

Evaluación normal con **mejora de eficiencia**

-  _recordar_ que las copias de un argumento son el mismo valor, para no replicar trabajo.
</script></section><section data-markdown><script type="text/template">
#### Ejemplo

```haskell
ones = 1:ones

-- take 10 ones = ??
```
<!-- .element: contenteditable="true" -->
</script></section><section data-markdown><script type="text/template">
# Currificación
</script></section><section data-markdown><script type="text/template">
```haskell
inc :: Int -> Int
inc x = 1 + x

suma :: Int -> Int -> Int
suma x y = x + y

-- inc x = suma 1 x ??
```
<!-- .element: contenteditable="true" -->
</script></section><section data-markdown><script type="text/template">
# Funciones Lambda
</script></section><section data-markdown><script type="text/template">
-  Necesita una función que no vamos a referenciar, tener un nombre??
-  Si queremos devolver una función como valor de retorno
    -  Necesita estar previamente definida??
</script></section><section data-markdown><script type="text/template">
### Ejemplo

```haskell
inc :: Int -> Int
-- inc x = 1 + x
inc = \x -> 1 + x
```
<!-- .element: contenteditable="true" -->
</script></section><section data-markdown><script type="text/template">
# Recursión
</script></section><section data-markdown><script type="text/template">
```haskell
let list = [1, 2, 5, 8, 0, 10]

list !! 3
-- 8
```
<!-- .element: contenteditable="true" -->
</script></section><section data-markdown><script type="text/template">
```haskell
let fibs = 0 : 1 : [ n | x <-[2..], let n = ((fibs !! (x-1)) + (fibs !! (x-2))) ]

fib :: Int -> Int
fib x = fibs !! x
```
<!-- .element: contenteditable="true" style="font-size: 17px" -->
</script></section><section data-markdown><script type="text/template">
```haskell
-- Analizar
fibs' a b = a:fibs' b (a+b)
-- fibs = fibs' 0 1 ??
```
<!-- .element: contenteditable="true" -->
</script></section><section data-markdown><script type="text/template">
Con Recursión y Pattern Matching,

```haskell
fib :: Int -> Int
fib 0 = 0
fib 1 = 1
fib n = ... ??
```
</script></section><section data-markdown><script type="text/template">
```haskell
fib :: Int -> Int
fib 0 = 0
fib 1 = 1
fib n = fib (n-1) + fib (n-2)
```
</script></section><section data-markdown><script type="text/template">
### Práctica
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

## Reducciones

- Reducir las siguientes expresiones en forma aplicativa y normal. Indicar qué funciones son estrictas, y cuáles no.

  - ```haskell 
    quin (doble 2 + doble 3)
    ```

  - ```haskell
    first (seven, inf)
    ```

  - ```haskell
    head [x | x <- [1..], x esPar]
    ```

  - ```haskell
    min ([0] ++ [1..])
    ```</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

## Lambdas

<!-- .slide: style="text-align: left" -->

- Redefinir las siguientes funciones con funciones anónimas

  - ```haskell
    inc x = x + 1
    ```
  - ```haskell
    apply f x = f x
    ```
  - ```haskell
    -- función que permite pasar los parametros al reves
    flip f x y = f y x
    ```
</script></section><section data-markdown><script type="text/template">
<!-- .slide: style="text-align: left" -->

## Recursión

<!-- .slide: style="text-align: left" -->

Definir recursivamente las siguientes funciones:

- power: toma un numero y un natural, devolviendo el resultado de elevar el primero a la potencia del segundo.

- prime: decide si el numero pasado es primo.
</script></section></section></div>
    </div>

    <script src="./lib/js/head.min.js"></script>
    <script src="./js/reveal.js"></script>

    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // Optional libraries used to extend on reveal.js
      var deps = [
        { src: './lib/js/classList.js', condition: function() { return !document.body.classList; } },
        { src: './plugin/markdown/marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
        { src: './plugin/markdown/markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
        { src: './plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
        { src: './plugin/zoom-js/zoom.js', async: true },
        { src: './plugin/notes/notes.js', async: true },
        { src: './plugin/math/math.js', async: true }
      ];

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        dependencies: deps
      };

      // options from URL query string
      var queryOptions = Reveal.getQueryHash() || {};

      var options = extend(defaultOptions, {}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
